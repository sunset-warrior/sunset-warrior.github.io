{"meta":{"title":"Evan的微博","subtitle":"自己动手，丰衣足食","description":"学习知识，掌握知识，分享知识，获得快乐","author":"Evan","url":"https://llblog.cn"},"pages":[],"posts":[{"title":"springboot事件发布监听","slug":"springboot-event-publish-and-listen","date":"2019-06-23T14:40:49.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/23/springboot-event-publish-and-listen/","permalink":"https://llblog.cn/2019/06/23/springboot-event-publish-and-listen/","excerpt":"","text":"近期在项目中遇到需要事件发布和监听的场景：以前存在一段比较复杂的代码流程，比如：创建的数据，在通过审批之后需要同步到其他表里边，现在需要在同步到其他表的同时需要计算某一批数据并推送给另外一个接口，那么我们该怎样发布我们的事件，并成功监听到，并且执行相关的逻辑呢？ 1. 定义事件我们定义一个事件，包括两个参数，此事件必须继承ApplicationEvent才可保证在publish时可以正常监听到 123456789101112131415161718192021222324252627282930313233343536public class CalCourierAndSalesDeptDistance extends ApplicationEvent &#123; /** * Create a new ApplicationEvent. * * @param source the object on which the event initially occurred (never &#123;@code null&#125;) */ private String type; private String deptCode; public CalCourierAndSalesDeptDistance(Object source, String type, String deptCode) &#123; super(source); this.type = type; this.deptCode = deptCode; &#125; public boolean isNotNull()&#123; return StringUtils.isNotEmpty(this.getType()) &amp;&amp; StringUtils.isNotEmpty(this.getDeptCode()); &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getDeptCode() &#123; return deptCode; &#125; public void setDeptCode(String deptCode) &#123; this.deptCode = deptCode; &#125;&#125; 2.如何发布事件？123456789101112131415@Componentpublic class DistanceCalPublish implements ApplicationEventPublisherAware &#123; private ApplicationEventPublisher applicationEventPublisher; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125; // 这个方法用于接收发送给监听的数据，并封装成事件对象，并发送给监听 public void publish(String type, String deptCode)&#123; CalCourierAndSalesDeptDistance calCourierAndSalesDeptDistance = new CalCourierAndSalesDeptDistance(this, type, deptCode); this.applicationEventPublisher.publishEvent(calCourierAndSalesDeptDistance); &#125;&#125; 本类继承ApplicationEventPublisherAware是用于发布事件使用，通过@Component是为了在SpringBoot启动的时候可以自动扫描到本类使用Bean来管理。代码里边applicationEventPublisher.publishEvent这个方法可以接收一个Object的类型数据（将定义的事件放到此处），所以可以将需要发送给监听事件的数据通过这个参数传输。 3.如何监听？1234567891011@Component@EnableAsync(proxyTargetClass=true)public class CalRegionDistanceHandler &#123; @Async(&quot;RegionDistanceHandlerExecutor&quot;) // 这里可以保证监听到创建的事件 @EventListener(classes = CalCourierAndSalesDeptDistance.class) public void handler(CalCourierAndSalesDeptDistance calCourierAndSalesDeptDistance) &#123; // 拿到数据，执行接下来的处理 &#125;&#125; @Component：上述代码中的作用和发布时相同。 @EnableAsync：打开异步执行，因为我们的事件的执行不需要影响原流程，所以异步即可。 方法handler：处理事件的方法，baseId是从发布事件的地方拿到的。 @EventListener：可开启对事件的监听。 @Async：异步处理的标志，括号中的参数为定义的线程池。 线程池的定义如下1234567891011121314@Configurationpublic class ConmmonConfig &#123; @Value(&quot;$&#123;common.threadPoolsSize:20&#125;&quot;) private int threadPoolsSize; @Bean(&quot;RegionDistanceHandlerExecutor&quot;) public ThreadPoolTaskExecutor msgHandlerExecutor()&#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(threadPoolsSize); taskExecutor.setMaxPoolSize(threadPoolsSize); return taskExecutor; &#125;&#125; 3.如何使用？ 在使用的类中先注入该publish 12@AutowiredGridSplitPublish publish; 在合适的实际发布事件 12publish.publish(xxxx);// 其中xxx为需要发送给事件监听的参数 4.事件监听到此为止","categories":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"事件监听","slug":"事件监听","permalink":"https://llblog.cn/tags/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"== 和 equals 的区别是什么？","slug":"equals-meaning","date":"2019-06-23T14:33:59.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/23/equals-meaning/","permalink":"https://llblog.cn/2019/06/23/equals-meaning/","excerpt":"","text":"简单来说，此题的结论可以总结为：”&#x3D;&#x3D;”相等判断符用于比较基本数据类型和引用类型数据。 当比较基本数据类型的时候比较的是数值，当比较引用类型数据时比较的是引用(指针)。而equals是引用类型自定义的判断是否相等的方法。那么问题来了：首先什么是基本数据类型：在java中基本数据类型总共有八种：分别是int，float，char，boolean，double，long，short，byte他们在判断是否相等的时候就可直接使用”&#x3D;&#x3D;”例如： int a = 10; int b = 10; System.out.println(a == b); // true 引用类型在开发过程中最多用到的就是String了。 1. String a = &quot;abc&quot;; 2. String b = &quot;abc&quot;; 3. System.out.println(a == b); // true 这里可能有人会有疑问，为什么使用的 &#x3D;&#x3D; 判断结果会是true，解释如下：其实第1行代码只是创建了一个对象，结果是将”abc”放到了字符串常量池，而a指向了它，第二句代码执行的时候编译器会发现字符串常量池里边已经存在了该常亮，所以不会再次创建，而只是创建了一个新的指针b指向它，所以当执行&#x3D;&#x3D;时，由于a和b指向的是同一个字符串常量，所以结果为true 4. String c = new String(&quot;abc); 5. System.out.println( a == c); // false 第4行代码在堆（heap)中创建了一个对象，然后将字符串常亮池里边的”abc”指向它，而且它自己指向了常量c，所以在使用 “&#x3D;&#x3D;” 时，实质上判断的是常量池中的”abc”和堆中保存的对象，结果肯定是false，所以String才内置了equals方法来判断他们是否值相同，具体的可以看看String的equls的源码。 基础知识：栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。 堆（heap）：用于存储对象","categories":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/tags/%E6%9D%82%E8%B0%88/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"mysql序列的创建","slug":"mysql-sequence-1","date":"2019-06-09T14:32:24.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/09/mysql-sequence-1/","permalink":"https://llblog.cn/2019/06/09/mysql-sequence-1/","excerpt":"","text":"mysql的序列接介绍mysql中没有像oracle中的序列那样方便，但是我们可以使用特殊的表结构，加上自定义函数来完成相关的功能。 不废话，直接看代码！1、先创建一个表，用于存储所有的序列。CREATE TABLE `sequence` ( `sequence_name` varchar(100) NOT NULL COMMENT &#39;序列的名称&#39;, `current_value` int(11) DEFAULT &#39;1&#39; COMMENT &#39;当前值&#39;, `increment` int(11) DEFAULT &#39;1&#39; COMMENT &#39;步长（每次增长的大小）&#39;, PRIMARY KEY (`sequence_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2、新增一个自定义函数（UDF），用户快速新增序列解释：向序列表里边新增一条数据。 CREATE FUNCTION CREATE_SEQ (seq_name VARCHAR(100),step_num INT UNSIGNED) RETURNS VARCHAR(50) BEGIN DECLARE result VARCHAR(100); DECLARE tempNum INT; SET result = &#39;The sequence has exist!&#39;; SET tempNum = (SELECT current_value FROM sequence WHERE sequence_name = seq_name); IF ISNULL(tempNum)=1 THEN INSERT INTO sequence (sequence_name,increment) VALUES (seq_name,step_num); SET result =&#39;CREATED SUCCESS&#39;; END IF; RETURN result; END 3、新增一个自定义函数（UDF），用于查找序列解释：将表中的current_value查找出来，同时将current_value加上步长，用于下次查询。 CREATE FUNCTION next_value(seq_name VARCHAR(100)) RETURNS INT BEGIN DECLARE result_num INT; DECLARE tempNum INT; SET result_num = 0; SET tempNum = (SELECT current_value FROM sequence WHERE sequence_name = seq_name); IF ISNULL(tempNum)=0 THEN SET result_num=tempNum; UPDATE sequence SET current_value = current_value+increment WHERE sequence_name = seq_name; END IF; RETURN result_num; END 4、新增一个自定义函数（UDF），用于重置序列解释：将表中的current_value重置为1，用于下次查询。 CREATE FUNCTION reset_sequence(seq_name VARCHAR(100)) RETURNS VARCHAR(100) BEGIN DECLARE result VARCHAR(100); DECLARE tempNum INT; SET result = &#39;NOT EXISTS THIS SEQUENCE!&#39;; SET tempNum = (SELECT current_value FROM sequence WHERE sequence_name = seq_name); IF ISNULL(tempNum)=0 THEN UPDATE sequence SET current_value = 1 WHERE sequence_name = seq_name; SET result = &#39;RESET SUCCESS&#39;; END IF; RETURN result; END 使用的时候直接使用： select 函数名([参数]); OK，mysql的序列到此完成，总体来说，此次创建的序列的功能和oracle的序列比较起来，功能还是比较单一，但是提供了另外一种解决问题的思路。 希望看到此博文的同学可以对mysql的序列有一个比较简单的认识，并学会一些mysql的基本使用方法。 加油！","categories":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://llblog.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://llblog.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"关于mysql聚合函数的学习","slug":"mysql-aggregate-function-1","date":"2019-06-08T15:24:12.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/08/mysql-aggregate-function-1/","permalink":"https://llblog.cn/2019/06/08/mysql-aggregate-function-1/","excerpt":"","text":"关于mysql聚合函数的学习可以参考官方对于聚合函数的定义。官方解释：mysql聚合函数 下面仅列出项目开发中使用频率较高的几种聚合函数1. AVG()或者AVG([DISTINCT] expr)官方解释：Returns the average value of expr. The DISTINCT option can be used to return the average of the distinct values of expr.描述：Return the average value of the argument翻译：返回待计算参数的平均值使用方法： 现在存在一张学生表，建表语句如下 CREATE TABLE `student` ( `id` int(10) NOT NULL AUTO_INCREMENT, `stu_no` varchar(20) DEFAULT NULL, `stu_name` varchar(100) DEFAULT NULL, `stu_age` int(2) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; 接下来我们新增三条数据 INSERT INTO student (stu_no, stu_name, stu_age)VALUES(&#39;C20190608001&#39;,&#39;张三&#39;,&#39;17&#39;),(&#39;C20190608002&#39;,&#39;李四&#39;,&#39;18&#39;),(&#39;C20190608003&#39;,&#39;王五&#39;,&#39;19&#39;); 现在表内容如下所示： 1 C20190608001 张三 17 2 C20190608002 李四 18 3 C20190608003 王五 19 需求：需要查询这张表所有人员平均年龄。（运行结果：18） SELECT AVG(stu_age) FROM student; 当我们向表中再增加一条数据时： INSERT INTO student (stu_no, stu_name, stu_age)VALUES(&#39;C20190608004&#39;,&#39;赵六&#39;,&#39;19&#39;); 需求：查询此表中不同年龄的学生的平均年龄。这个时候我们只需要对上一个SQL做简单修改。（运行结果：18） SELECT AVG(DISTINCT stu_age) FROM student; 2. COUNT()或者COUNT([DISTINCT] expr,[expr…]) 官方解释：Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value. 描述：Return a count of the number of rows returned 翻译：返回查询结果行数 使用方法： 需求：返回学生表中的学生个数 SELECT COUNT(*) FROM student; 需求：返回学生表中不同的年龄有多少种 SELECT COUNT(DISTINCT stu_age) FROM student; 3.MAX()或者MAX([DISTINCT] expr)官方描述：Return the maximum value.翻译：返回最大值官方解释：Returns the maximum value of expr. MAX() may take a string argument; in such cases,it returns the maximum string value. See Section 8.3.1, “How MySQL Uses Indexes”.The DISTINCT keyword can be used to find the maximum of the distinct values of expr,however, this produces the same result as omitting DISTINCT.使用方法： 同上述方法。 4.MIN()或者MAX([DISTINCT] expr)官方描述：Return the minimum value.翻译：返回最大值官方解释：Returns the minimum value of expr. MIN() may take a string argument; in such cases, it returns the minimum string value. See Section 8.3.1, “How MySQL Uses Indexes”. The DISTINCT keyword can be used to find the minimum of the distinct values of expr, however, this produces the same result as omitting DISTINCT.使用方法： 同上述方法。 5.SUM()或者SUM([DISTINCT] expr)官方描述：Return the sum.翻译：返回合计值官方解释：Returns the sum of expr. If the return set has no rows, SUM() returns NULL.The DISTINCT keyword can be used to sum only the distinct values of expr.使用方法： 同上述方法。 注：所有的DISTINCT，使用的时机为当需要统计去重之后的数据时使用。希望大家在看过这一片博文之后能对mysql的聚合函数有一定的了解和学会简单的使用。加油！","categories":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://llblog.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://llblog.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"Mysql的函数的创建","slug":"mysql-function-1","date":"2019-06-08T02:42:41.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/08/mysql-function-1/","permalink":"https://llblog.cn/2019/06/08/mysql-function-1/","excerpt":"","text":"Mysql的函数的创建一、什么是mysql的自定义函数？官方解释：A user-defined function (UDF) is a way to extend MySQL with a new function that works like a native (built-in) MySQL function such as ABS() or CONCAT().翻译：用户自定义函数，英文缩写：(UDF)，是一种对于扩展mysql功能的方法，类似于ABS()或者CONCAT()。 二、为什么要学会mysql的自定义函数的创建？因为我们在项目开发的过程中，总是会遇到各种各样的对于不同的业务而需要对数据进行不同展示和处理的情况，而直接查询保存在数据库中的数据，即使使用了数据库内置的函数，依然不能很好的完成这部分功能，在以前，这一部分的工作往往是交给编程语言在开发的过程中完成的，但其实，在某些情况下，我们可以使用mysql的自定义函数来完成我们对于数据的处理，所以从今天起，我们又将学习一门新的技能。 三、那么如何学习mysql的自定义函数呢？这一部分我们将会分成三部分进行讲解 mysql自定义函数的结构 对结构的每一部分进行解释 学习几个小栗子，进行实战模拟 四、接下来，开始我们的学习1、函数结构先看看mysql官方对于mysql函数创建的描述。在页面的上方你会很方便的看到对于自定义函数结构的展示，就是下面这个样子。 CREATE [AGGREGATE] FUNCTION function_name RETURNS &#123;STRING|INTEGER|REAL|DECIMAL&#125; SONAME shared_library_name 但是实质上，自定义函数的结构应该是下面这个样子的。 CREATE [AGGREGATE] FUNCTION function_name(parameter_name type,[parameter_name type,...]) RETURNS &#123;STRING|INTEGER|REAL&#125; runtime_body 接下来我们来看一下这个结构中的每项的含义。a. 中括号[和]在学习编程开发的过程中，在很多文档里边你会看到这个符号，请记住，这个符号的含义是括号包起来的内容在实际使用中是需要根据实际情况选择使用的。换句话说，就是可以使用，也可以不使用，而[和]是不需要写进程序的。谨记！b. AGGREGATE这个单词在mysql中，往往是在创建聚合函数的过程中使用到，那么什么是聚合函数？在mysql中，类似于sum(),count(),max()等都是聚合函数，这些函数在实际项目开发中的作用很大，建议多储备。关于聚合函数，可以参考博主的另一篇文章关于mysql聚合函数的学习。c.parameter_name解释：参数名d.type解释：参数类型e.runtime_body解释：运行代码（函数体） 2、实际上手注意：所有自定义函数的目的都是为了输出数据，所以每个自定义函数必须规定返回值，函数的参数可有可无，具体按照实际情况而定需求：（无参函数）需要输出当前日期的年月数据，格式为”yyyy-MM”，类似”2012-12” CREATE FUNCTION cur_year_month() RETURNS VARCHAR(20) RETURN (select DATE_FORMAT(now(),&#39;%Y-%m&#39;)); 注：1. 函数无论有无参数函数后面的括号必须存在， 2.当return后面是一个查询语句时，必须将查询语句放到括号里边，否则会报错。 3.当函数体存在多条语句时，需使用BEGIN 和 END将函数体包含。 附加知识：mysql中format的格式有一下几种： format样式整理： 年： %Y 显示四位 ： 2015 %y 只显示后两位 ：15 月： %M 月份的英文显示：October %m 月份的阿拉伯显示：01-12 %b 月份的英文缩略显示：Oct %c 月份的阿拉伯显示：1-12 日： %d 阿拉伯显示：00-31 %D 带有英文后缀：1st-31th %e 阿拉伯显示：1-31 %j 年的天：001-366 时： %H ：00-23 %h:01-12 %I:01-12 %k:0-23 %l:1-12 分： %i：00-59 秒： %S：00-59 %s:00-59 微妙： %f AM/PM:%p 12小时制时间：%r: 02:02:44 PM 24小时制时间： %T： 14:02:44 周： %W：周的英文显示 %w 周的阿拉伯显示 ：0（星期日）-6（星期六） %a 周的英文缩略显示：Mon- 需求：（有参函数）需要输出两个数字的商 CREATE FUNCTION shang(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED) RETURNS FLOAT(7,2) RETURN num1/num2; 注：SMALLINT 数据类型是一种精确数值数据类型，其精度在算术运算后不变。它需要 2 个字节存储。 有符号的 SMALLINT 值的范围是 –2^15（2^15表示2的15次幂） 到2^15 – 1，即 –32768 到 32767。 无符号的 SMALLINT 值范围是 0 到 2^16 – 1，即 0 到 65535。 INT 是4字节数据，取值范围 -2^31 - 2^31, 所以在考虑最大数据范围的前提下，优先使用smallint类型。 UNSIGNED 代表无符号。所以我们在调用上面的函数时，最大可传的参数是65535，假如我们去掉了UNSIGNED的限制，最大就只能传–32768 到 32767的数字。因为我们定义FLOAT的限制为(7,2)，表示结果的整数最多为（7-2&#x3D;5）位，而小数位最多为2位，谨记。 3、删除函数 当我们自定义的函数不再使用的时候，可以使用下面的方式来删除 DROP FUNCTION FUNCTION_NAME 举例：比如我们要删除我们上面创建的函数就可以执行下面这个语句。 DROP FUNCTION shang 上述为mysql具体创建函数的过程，希望可以看到此篇博文的同学对mysql的函数有一个初步的了解，和学会简单的使用。加油！","categories":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://llblog.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://llblog.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://llblog.cn/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"learning_english","slug":"learning-english-1","date":"2019-06-02T14:18:11.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/02/learning-english-1/","permalink":"https://llblog.cn/2019/06/02/learning-english-1/","excerpt":"","text":"1、continue 继续；连续 Few people want the war to continue.几乎没有人想这个战争继续下去2、leave alone 不管；不理会；更不用说 Leave him alone.He has already become blind drunk.不管他了。他已经喝的烂醉如泥了。3、travle 旅行；旅游 to travle on the ship乘坐轮船旅行4、copper 铜，铜币Copper conducts electricity better than iron does.铜的导电性比铁强。5、garment 衣服；外衣；给…穿衣服 to garment the model给模特穿衣服6、halfway 半路；中途；中途的 We had got only halfway when it began to get dark.我们才走到半路，天就黑了。7、molecule 分子 A molecule is made up of atoms.分子是由原子构成的。8、terrible 可怕的；极坏的；糟糕的 Your writing is terrible.你的字写得真糟糕。9、The Department of Health 卫生部；卫生署 The Department of Health is conducting social recruitment of civil servants.卫生部正在面向社会招收公务员10、come across 偶遇；偶然发现；使…产生印象Have you come accross anything like that?你曾经遇到过类型的事情吗？","categories":[{"name":"英语角","slug":"英语角","permalink":"https://llblog.cn/categories/%E8%8B%B1%E8%AF%AD%E8%A7%92/"}],"tags":[{"name":"English","slug":"English","permalink":"https://llblog.cn/tags/English/"}],"keywords":[{"name":"英语角","slug":"英语角","permalink":"https://llblog.cn/categories/%E8%8B%B1%E8%AF%AD%E8%A7%92/"}]},{"title":"关于近期的计划","slug":"recent-plan","date":"2019-06-02T14:02:25.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/02/recent-plan/","permalink":"https://llblog.cn/2019/06/02/recent-plan/","excerpt":"","text":"关于近期的一些计划今天又开始拿起来这个博客了，刚考虑了好久近期博客更新的内容，原想更新写Spring源码的一些东西，把jar包打开看了看还是放弃了，ヽ(ー_ー)ノ，说实话，还是有点难度的，都想放弃了，然后又看到了陈杰的博客，还是想把自己比较熟悉的东西做一些分享，比如mybatis的一些使用之类的，然后还想在博客里边加一个英语角，算作学习英语的一个小用途把。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"计划","slug":"计划","permalink":"https://llblog.cn/tags/%E8%AE%A1%E5%88%92/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"自我介绍","slug":"introduce-myself","date":"2019-06-02T12:38:27.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/06/02/introduce-myself/","permalink":"https://llblog.cn/2019/06/02/introduce-myself/","excerpt":"","text":"个人简介一、自我介绍一名普普通通的程序员，目前在做Java开发，许多技术不敢说精通，掌握技术包括：SpringBoot，spring，mybatis，jsp，html，css，javascript，jquery，vue等。希望在接下来的日子里能通过这个博客来分享和学习许多新的知识和技术，并对已经了解的技术进行更多更深的研究。谢谢！二、联系邮箱sunset_warrior@163.com希望有更多的志同道合的猿有交流学习","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"个人简介","slug":"个人简介","permalink":"https://llblog.cn/tags/%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/categories/%E6%9D%82%E8%B0%88/"}]},{"title":"markdown示例","slug":"studyMarkdown","date":"2019-05-23T12:00:43.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/05/23/studyMarkdown/","permalink":"https://llblog.cn/2019/05/23/studyMarkdown/","excerpt":"","text":"1、Markdown标题这里是一级标题这里是二级标题2、Markdown段落一、段落段落的换行是使用两个以上的空格加上回车下面这段我回车了，但是没有加空格，看看效果二、字体1、斜体文本2、斜体文本3、粗体文本4、粗体文本5、斜粗体文本 三、分割线 四、下划线下划线 Markdown列表 第一项 第二项 第三项 1、第一项区块引用 区块引用 llblog 开始的开发 第二层 print(&#39;打印&#39;); function test()&#123; console.log(); &#125; lksdjflkdk","categories":[{"name":"前端","slug":"前端","permalink":"https://llblog.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://llblog.cn/tags/markdown/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://llblog.cn/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"本人的第一条博客","slug":"myfirstblog","date":"2019-05-23T11:58:43.000Z","updated":"2019-06-25T07:22:41.000Z","comments":true,"path":"2019/05/23/myfirstblog/","permalink":"https://llblog.cn/2019/05/23/myfirstblog/","excerpt":"","text":"这是第一次使用markdown编辑的博客，今天比较忙，先提交了，等有时间了，会把整个工程优化一下，下次发博客的内容是markdown的结构。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://llblog.cn/tags/%E6%A0%87%E7%AD%BE/"}],"keywords":[{"name":"杂谈","slug":"杂谈","permalink":"https://llblog.cn/categories/%E6%9D%82%E8%B0%88/"}]}]}